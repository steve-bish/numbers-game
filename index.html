<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes" />
  <meta name="theme-color" content="#1f2937" />

  <title>Number Merge</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    #root {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

/* =======================
   CONFIG
======================= */

const GRID_WIDTH = 5;
const GRID_HEIGHT = 7;

const CELL_SIZE = 64;
const CELL_RADIUS = CELL_SIZE / 2;

const POWERS = [
  1, 2, 4, 8, 16, 32, 64, 128,
  256, 512, 1024, 2048, 4096,
  8192, 16384, 32768, 65536,
  131072, 262144
];

const COLORS = {
  1: '#4DD0E1',
  2: '#9575CD',
  4: '#81C784',
  8: '#FFD54F',
  16: '#FF8A65',
  32: '#64B5F6',
  64: '#E57373',
  128: '#4DB6AC',
  256: '#BA68C8',
  512: '#AED581',
  1024: '#FFB74D',
  2048: '#7986CB',
  4096: '#F06292',
  8192: '#4FC3F7',
  16384: '#81C784',
  32768: '#FF8A65',
  65536: '#9575CD',
  131072: '#4DB6AC',
  262144: '#FFD54F'
};

/* =======================
   HELPERS
======================= */

const getRandomNumber = () =>
  POWERS[Math.floor(Math.random() * POWERS.length)];

const formatNumber = (num) => {
  if (num < 10000) return num.toString();
  if (num < 1_000_000) return `${Math.floor(num / 1000)}K`;
  return `${Math.floor(num / 1_000_000)}M`;
};

const getTextColorForBackground = (hex) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness > 160 ? '#111827' : '#FFFFFF';
};

/* =======================
   GRAVITY (PURE)
======================= */

const applyGravity = (grid) => {
  const newGrid = grid.map(r => [...r]);
  const animations = new Map();

  for (let col = 0; col < GRID_WIDTH; col++) {
    let writeRow = GRID_HEIGHT - 1;

    for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
      if (newGrid[row][col] !== null) {
        if (row !== writeRow) {
          newGrid[writeRow][col] = newGrid[row][col];
          newGrid[row][col] = null;
          animations.set(`${writeRow}-${col}`, writeRow - row);
        }
        writeRow--;
      }
    }
  }

  return { newGrid, animations };
};

/* =======================
   COMPONENT
======================= */

const NumberMergeGame = () => {
  const [grid, setGrid] = useState([]);
  const [path, setPath] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [animatingCells, setAnimatingCells] = useState(new Map());
  const [removedCells, setRemovedCells] = useState(new Set());
  const [suckingCells, setSuckingCells] = useState(new Map());
  const [mergedCell, setMergedCell] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const gridRef = useRef(null);

  useEffect(() => initializeGrid(), []);

  const initializeGrid = () => {
    const g = Array.from({ length: GRID_HEIGHT }, () =>
      Array.from({ length: GRID_WIDTH }, getRandomNumber)
    );
    setGrid(g);
  };

  const getCellPosition = (row, col) => {
    const cells = gridRef.current.querySelectorAll('.grid-cell');
    const cell = cells[row * GRID_WIDTH + col];
    const rect = cell.getBoundingClientRect();
    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
  };

  const handleDragStart = (row, col) => {
    if (isProcessing) return;
    setIsDragging(true);
    setPath([{ row, col }]);
  };

  const handlePointerMove = (e) => {
    if (!isDragging) return;
    const el = document.elementFromPoint(e.clientX, e.clientY);
    if (!el?.classList.contains('grid-cell')) return;

    const cells = [...gridRef.current.querySelectorAll('.grid-cell')];
    const idx = cells.indexOf(el);
    const row = Math.floor(idx / GRID_WIDTH);
    const col = idx % GRID_WIDTH;

    const last = path[path.length - 1];
    if (last?.row === row && last.col === col) return;

    setPath([...path, { row, col }]);
  };

  const getPathValue = () =>
    path.reduce((v) => v * 2, grid[path[0].row][path[0].col]);

  const handleDragEnd = async () => {
    if (path.length < 2) {
      setPath([]);
      setIsDragging(false);
      return;
    }

    setIsProcessing(true);
    const finalValue = getPathValue();
    const lastCell = path[path.length - 1];

    /* suction */
    const suck = new Map();
    path.slice(0, -1).forEach(c =>
      suck.set(`${c.row}-${c.col}`, {
        deltaRow: lastCell.row - c.row,
        deltaCol: lastCell.col - c.col
      })
    );
    setSuckingCells(suck);
    setMergedCell(`${lastCell.row}-${lastCell.col}`);
    await new Promise(r => setTimeout(r, 400));

    /* logical grid */
    const logical = grid.map(r => [...r]);
    path.slice(0, -1).forEach(c => logical[c.row][c.col] = null);
    logical[lastCell.row][lastCell.col] = finalValue;

    /* gravity */
    const { newGrid, animations } = applyGravity(logical);

    /* spawn */
    for (let col = 0; col < GRID_WIDTH; col++) {
      for (let row = 0; row < GRID_HEIGHT; row++) {
        if (newGrid[row][col] === null) {
          newGrid[row][col] = getRandomNumber();
          animations.set(`${row}-${col}`, GRID_HEIGHT);
        }
      }
    }

    setGrid(newGrid);
    setAnimatingCells(animations);

    await new Promise(r => setTimeout(r, 800));

    setPath([]);
    setSuckingCells(new Map());
    setMergedCell(null);
    setAnimatingCells(new Map());
    setIsDragging(false);
    setIsProcessing(false);
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-200 p-4">
      <div className="bg-white rounded-3xl p-8 shadow-2xl">
        <h1 className="text-3xl font-bold mb-4">Number Merge</h1>

        <div
          ref={gridRef}
          className="grid gap-3 relative bg-gray-900 p-4 rounded-3xl"
          style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
          onPointerMove={handlePointerMove}
          onPointerUp={handleDragEnd}
        >
          {grid.map((row, r) =>
            row.map((value, c) => {
              const key = `${r}-${c}`;
              const suck = suckingCells.get(key);
              const drop = animatingCells.get(key);

              let transform = 'translateY(0)';
              if (suck) {
                transform = `translate(${suck.deltaCol * 68}px, ${suck.deltaRow * 68}px) scale(0.5)`;
              }

              return (
                <div
                  key={key}
                  className="grid-cell w-16 h-16 rounded-2xl flex items-center justify-center font-bold cursor-pointer"
                  style={{
                    backgroundColor: COLORS[value],
                    color: getTextColorForBackground(COLORS[value]),
                    transform,
                    transition: 'all 0.4s ease',
                    ...(drop && { animation: `dropIn-${drop} 0.8s ease` })
                  }}
                  onPointerDown={() => handleDragStart(r, c)}
                >
                  {formatNumber(value)}
                </div>
              );
            })
          )}
        </div>

        <button
          onClick={initializeGrid}
          className="mt-6 w-full bg-purple-600 text-white py-3 rounded-xl font-semibold"
        >
          New Game
        </button>
      </div>
    </div>
  );
};

ReactDOM.render(<NumberMergeGame />, document.getElementById('root'));
</script>
</body>
</html>