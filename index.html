<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Merge">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%23111827'/><text y='70' x='10' font-family='sans-serif' font-weight='bold' font-size='70' fill='white'>M</text></svg>">
  
  <title>Number Merge</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body, html {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background-color: #f3f4f6; touch-action: none;
      -webkit-tap-highlight-color: transparent; user-select: none;
    }

    #root { height: 100%; display: flex; align-items: center; justify-content: center; }

    /* --- ANIMATIONS --- */
    @keyframes gravityDrop {
      0% { transform: translateY(var(--startY)); }
      100% { transform: translateY(0); }
    }

    @keyframes suction {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; }
    }

    @keyframes popMerge {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    @keyframes particleFade {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    .particle {
      position: absolute; pointer-events: none; border-radius: 50%;
      z-index: 60; animation: particleFade 0.6s ease-out forwards;
    }

    .cell-text { position: relative; z-index: 40; pointer-events: none; }
    
    .grid-cell { transition: background-color 0.2s, box-shadow 0.2s, border 0.2s; }

    @keyframes indicatorPop {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .preview-pop { animation: indicatorPop 0.2s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;
    const COLORS = {
      1: '#4DD0E1', 2: '#9575CD', 4: '#81C784', 8: '#FFD54F',
      16: '#FF8A65', 32: '#64B5F6', 64: '#E57373', 128: '#4DB6AC',
      256: '#BA68C8', 512: '#AED581', 1024: '#FFB74D', 2048: '#7986CB',
      4096: '#F06292', 8192: '#4FC3F7', 16384: '#81C784', 32768: '#FF8A65'
    };

    let idCounter = 0;
    const getNextTileValue = (maxOnGrid) => {
      // Logic: Drop numbers up to MaxTile / 8 (e.g. if max is 128, drop up to 16)
      // We cap the base drop at 16 to keep the game from becoming too easy
      const exponentLimit = Math.max(3, Math.min(5, Math.floor(Math.log2(maxOnGrid || 1)) - 2));
      return Math.pow(2, Math.floor(Math.random() * exponentLimit));
    };

    const createTile = (val) => ({ val, id: idCounter++ });

    const getTextColor = (hex) => {
      if (!hex) return '#fff';
      const r = parseInt(hex.slice(1,3), 16), g = parseInt(hex.slice(3,5), 16), b = parseInt(hex.slice(5,7), 16);
      return (r*299 + g*587 + b*114)/1000 > 160 ? '#111827' : '#fff';
    };

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [score, setScore] = useState(0);
      const [particles, setParticles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [animatingIds, setAnimatingIds] = useState(new Map());
      const [suckingIds, setSuckingIds] = useState(new Map());
      const [mergedId, setMergedId] = useState(null);

      useEffect(() => {
        const saved = localStorage.getItem('mergeSave');
        if (saved) {
          const data = JSON.parse(saved);
          setGrid(data.grid);
          setScore(data.score);
        } else {
          resetGame();
        }
      }, []);

      const resetGame = () => {
        idCounter = 0;
        const startGrid = Array.from({length: GRID_HEIGHT}, () => 
          Array.from({length: GRID_WIDTH}, () => createTile(Math.pow(2, Math.floor(Math.random() * 3))))
        );
        setGrid(startGrid);
        setScore(0);
        setPath([]);
      };

      const spawnParticles = (row, col, color) => {
        const newParticles = Array.from({ length: 15 }).map((_, i) => ({
          id: Math.random() + i,
          row, col, color,
          tx: (Math.random() - 0.5) * 200,
          ty: (Math.random() - 0.5) * 200,
          size: Math.random() * 6 + 4
        }));
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.filter(p => !newParticles.includes(p))), 600);
      };

      const handleDragStart = (r, c) => {
        if (isProcessing) return;
        setPath([{ row: r, col: c }]);
      };

      const handlePointerMove = (e) => {
        if (path.length === 0 || isProcessing) return;
        const touch = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!el || !el.dataset.coord) return;
        
        const [r, c] = el.dataset.coord.split('-').map(Number);
        const last = path[path.length - 1];
        if (last.row === r && last.col === c) return;

        if (path.length > 1) {
          const secondLast = path[path.length - 2];
          if (secondLast.row === r && secondLast.col === c) {
            setPath(path.slice(0, -1));
            return;
          }
        }

        const isAdj = Math.abs(last.row - r) <= 1 && Math.abs(last.col - c) <= 1;
        const val = grid[r][c].val;
        const lastVal = grid[last.row][last.col].val;

        if (isAdj && !path.find(p => p.row === r && p.col === c)) {
          if (path.length === 1) {
            if (val === lastVal) setPath([...path, { row: r, col: c }]);
          } else {
            if (val === lastVal || val === lastVal * 2) setPath([...path, { row: r, col: c }]);
          }
        }
      };

      const pathValue = useMemo(() => {
        if (path.length === 0) return 0;
        let total = grid[path[0].row][path[0].col].val;
        for(let i = 1; i < path.length; i++) {
          const v = grid[path[i].row][path[i].col].val;
          if (v === total || v === total * 2) total *= 2;
        }
        return total;
      }, [path, grid]);

      // Path length multiplier (e.g. 5 cells = 2.5x score)
      const multiplier = useMemo(() => {
        return Math.max(1, path.length / 2);
      }, [path]);

      const handleDragEnd = async () => {
        if (path.length < 2) { setPath([]); return; }
        setIsProcessing(true);

        const finalVal = pathValue;
        const scoreGain = Math.floor(finalVal * multiplier);
        const last = path[path.length - 1];
        const others = path.slice(0, -1);
        const mergeColor = COLORS[finalVal] || '#fff';
        const targetId = grid[last.row][last.col].id;

        const suckMap = new Map();
        others.forEach(p => suckMap.set(grid[p.row][p.col].id, { x: (last.col - p.col) * 70, y: (last.row - p.row) * 70 }));
        setSuckingIds(suckMap);
        
        await new Promise(r => setTimeout(r, 200));

        spawnParticles(last.row, last.col, mergeColor);
        const g1 = grid.map(row => row.map(cell => ({...cell})));
        others.forEach(p => g1[p.row][p.col] = { val: 0, id: -1 });
        g1[last.row][last.col] = { val: finalVal, id: targetId };
        
        setPath([]);
        setSuckingIds(new Map());
        setMergedId(targetId);
        setGrid(g1);
        setScore(s => s + scoreGain);

        await new Promise(r => setTimeout(r, 100));

        const g2 = g1.map(row => [...row]);
        const dropMap = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let empty = 0;
          for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
            if (g2[r][c].val === 0) empty++;
            else if (empty > 0) {
              const tile = g2[r][c];
              g2[r+empty][c] = tile;
              g2[r][c] = { val: 0, id: -1 };
              dropMap.set(tile.id, empty);
            }
          }
        }
        setGrid(g2);
        setAnimatingIds(dropMap);

        await new Promise(r => setTimeout(r, 300));

        // Find max on board for dynamic spawning
        const maxVal = Math.max(...g2.flat().map(t => t.val));

        const g3 = g2.map(row => [...row]);
        const spawnMap = new Map(dropMap);
        for (let c = 0; c < GRID_WIDTH; c++) {
          let emptyCount = 0;
          for (let r = 0; r < GRID_HEIGHT; r++) if (g3[r][c].val === 0) emptyCount++;
          for (let r = 0; r < emptyCount; r++) {
            const newVal = getNextTileValue(maxVal);
            const newTile = createTile(newVal);
            g3[r][c] = newTile;
            spawnMap.set(newTile.id, emptyCount + 2);
          }
        }
        setGrid(g3);
        setAnimatingIds(spawnMap);

        await new Promise(r => setTimeout(r, 400));
        setAnimatingIds(new Map());
        setMergedId(null);
        setIsProcessing(false);
        localStorage.setItem('mergeSave', JSON.stringify({ grid: g3, score: score + scoreGain }));
      };

      const formatVal = (v) => v >= 1000 ? (v/1000)+'K' : v;

      return (
        <div className="flex flex-col items-center justify-between h-full w-full max-w-md py-12 px-4">
          <div className="w-full flex justify-between items-center px-2">
            <h1 className="text-3xl font-black text-gray-800 tracking-tighter leading-none">MERGE</h1>
            <div className="bg-white shadow-sm border border-gray-100 px-6 py-2 rounded-2xl text-center">
              <p className="text-[10px] font-bold text-gray-400 uppercase">Score</p>
              <p className="text-xl font-black text-gray-800">{score.toLocaleString()}</p>
            </div>
          </div>

          <div className="h-24 flex items-center justify-center w-full">
            {path.length > 1 && (
              <div key={pathValue} className="preview-pop flex flex-col items-center justify-center bg-white w-24 h-24 rounded-full shadow-xl border-4 relative" style={{ borderColor: COLORS[pathValue] }}>
                {multiplier > 1 && (
                    <div className="absolute -top-2 -right-2 bg-red-500 text-white text-[10px] font-bold px-2 py-1 rounded-full shadow-lg">
                        {multiplier}x
                    </div>
                )}
                <p className="text-[9px] font-bold text-gray-400 uppercase leading-none mb-1">Result</p>
                <p className="text-3xl font-black" style={{ color: COLORS[pathValue] }}>{formatVal(pathValue)}</p>
              </div>
            )}
          </div>

          <div 
            ref={gridRef}
            className="relative grid gap-2 bg-gray-900 p-3 rounded-[2.5rem] shadow-2xl overflow-hidden"
            style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
            onTouchMove={handlePointerMove}
            onMouseMove={handlePointerMove}
            onMouseUp={handleDragEnd}
            onTouchEnd={handleDragEnd}
          >
            {grid.map((row, r) => row.map((tile, c) => {
              const key = `${r}-${c}`;
              const isPath = path.some(p => p.row === r && p.col === c);
              const suck = suckingIds.get(tile.id);
              const dropDist = animatingIds.get(tile.id);
              const isMerge = mergedId === tile.id;

              return (
                <div
                  key={tile.id === -1 ? `empty-${key}` : tile.id}
                  data-coord={key}
                  onMouseDown={() => handleDragStart(r, c)}
                  onTouchStart={() => handleDragStart(r, c)}
                  className="grid-cell w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-2xl font-black text-lg sm:text-xl relative"
                  style={{
                    backgroundColor: tile.val === 0 ? 'transparent' : (COLORS[tile.val] || '#374151'),
                    opacity: tile.val === 0 && !suck ? 0 : 1,
                    transform: isPath ? 'scale(1.15)' : 'none',
                    zIndex: isPath ? 30 : 10,
                    boxShadow: isPath ? `0 0 30px ${COLORS[pathValue]}cc` : 'none',
                    border: isPath ? `3px solid white` : 'none',
                    '--startY': `${-(dropDist || 0) * 100}%`,
                    '--suckX': `${suck?.x || 0}px`,
                    '--suckY': `${suck?.y || 0}px`,
                    animation: dropDist ? 'gravityDrop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards' : 
                               suck ? 'suction 0.2s ease-in forwards' : 
                               isMerge ? 'popMerge 0.3s ease-out' : 'none'
                  }}
                >
                  <span className="cell-text" style={{ color: getTextColor(COLORS[tile.val]) }}>
                    {tile.val > 0 ? formatVal(tile.val) : ''}
                  </span>
                </div>
              );
            }))}

            {particles.map(p => (
              <div 
                key={p.id} 
                className="particle"
                style={{
                  left: `${p.col * 20 + 10}%`,
                  top: `${p.row * 14.28 + 7.14}%`,
                  width: p.size, height: p.size,
                  backgroundColor: p.color,
                  '--tx': `${p.tx}px`, '--ty': `${p.ty}px`
                }}
              />
            ))}
          </div>

          <button onClick={resetGame} className="w-full bg-gray-900 text-white font-black py-5 rounded-3xl shadow-xl active:scale-95 transition-transform uppercase tracking-widest text-sm">
            New Game
          </button>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<NumberMergeGame />);
  </script>
</body>
</html>
