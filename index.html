<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Number Merge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f3f4f6; touch-action: none; -webkit-tap-highlight-color: transparent; user-select: none; }
    #root { height: 100%; display: flex; align-items: center; justify-content: center; }
    @keyframes gravityDrop { 0% { transform: translateY(var(--startY)); } 100% { transform: translateY(0); } }
    @keyframes suction { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; } }
    @keyframes popMerge { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
    @keyframes particleFade { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
    .particle { position: absolute; pointer-events: none; border-radius: 50%; z-index: 60; animation: particleFade 0.6s ease-out forwards; }
    .grid-cell { transition: background-color 0.2s, box-shadow 0.2s, border 0.2s; will-change: transform; }
    .preview-pop { animation: indicatorPop 0.2s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards; }
    @keyframes indicatorPop { 0% { transform: scale(0.8); opacity: 0; } 50% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;

    // HIGH CONTRAST CURATED PALETTE
    const TILE_COLORS = {
      2: '#47D1FF',      // Bright Cyan
      4: '#A855F7',      // Rich Purple
      8: '#22C55E',      // Grass Green
      16: '#F59E0B',     // Amber/Gold
      32: '#EF4444',     // Bright Red
      64: '#3B82F6',     // Royal Blue
      128: '#EC4899',    // Pink
      256: '#10B981',    // Emerald
      512: '#6366F1',    // Indigo
      1024: '#F97316',   // Orange
      2048: '#06B6D4',   // Dark Cyan
      4096: '#8B5CF6',   // Violet
      8192: '#D946EF',   // Fuchsia
      16384: '#14B8A6',  // Teal
      32768: '#64748B',  // Slate Blue
      65536: '#BE123C'   // Crimson
    };

    // Helper for values above the map
    const getTileColor = (val) => TILE_COLORS[val] || `hsl(${(Math.log2(val) * 40) % 360}, 70%, 50%)`;

    const getTextColor = (val) => {
        // Most of our colors are vibrant/dark, so white is usually best
        // We only use dark text for the very brightest colors
        const brights = [2, 8, 16, 256];
        return brights.includes(val) ? '#111827' : '#fff';
    };

    const formatVal = (v) => {
      if (v >= 1000000) return (v / 1000000).toFixed(v % 1000000 === 0 ? 0 : 1) + 'M';
      if (v >= 1000) return (v / 1000).toFixed(v % 1000 === 0 ? 0 : 1) + 'K';
      return v;
    };

    let globalIdCounter = 0;

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [score, setScore] = useState(0);
      const [particles, setParticles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [animatingIds, setAnimatingIds] = useState(new Map());
      const [suckingIds, setSuckingIds] = useState(new Map());
      const [mergedId, setMergedId] = useState(null);

      const createTile = (val) => ({ val, id: globalIdCounter++ });

      // CONSERVATIVE SPAWNING: Keeps the board from getting messy
      const getNextTileValue = () => {
        const rand = Math.random();
        if (rand > 0.95) return 16;
        if (rand > 0.85) return 8;
        if (rand > 0.60) return 4;
        return 2;
      };

      useEffect(() => {
        const saved = localStorage.getItem('mergeSaveV3');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            if (data.grid && typeof data.grid[0][0] === 'object') {
              setGrid(data.grid);
              setScore(data.score || 0);
              globalIdCounter = Math.max(...data.grid.flat().map(t => t.id)) + 1;
            } else { resetGame(); }
          } catch (e) { resetGame(); }
        } else { resetGame(); }
      }, []);

      const resetGame = () => {
        globalIdCounter = 0;
        const startGrid = Array.from({length: GRID_HEIGHT}, () => 
          Array.from({length: GRID_WIDTH}, () => createTile(Math.pow(2, Math.floor(Math.random() * 2) + 1)))
        );
        setGrid(startGrid);
        setScore(0);
        setPath([]);
      };

      const spawnParticles = (row, col, color) => {
        const newParticles = Array.from({ length: 12 }).map((_, i) => ({
          id: Math.random() + i, row, col, color,
          tx: (Math.random() - 0.5) * 200, ty: (Math.random() - 0.5) * 200, size: Math.random() * 5 + 3
        }));
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.filter(p => !newParticles.includes(p))), 600);
      };

      const handlePointerMove = (e) => {
        if (path.length === 0 || isProcessing) return;
        const touch = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!el || !el.dataset.coord) return;
        const [r, c] = el.dataset.coord.split('-').map(Number);
        const last = path[path.length - 1];
        if (last.row === r && last.col === c) return;

        if (path.length > 1) {
          const secondLast = path[path.length - 2];
          if (secondLast.row === r && secondLast.col === c) {
            setPath(path.slice(0, -1)); return;
          }
        }

        const isAdj = Math.abs(last.row - r) <= 1 && Math.abs(last.col - c) <= 1;
        const val = grid[r][c].val;
        const lastVal = grid[last.row][last.col].val;

        if (isAdj && !path.find(p => p.row === r && p.col === c)) {
          if (path.length === 1) {
            if (val === lastVal) setPath([...path, { row: r, col: c }]);
          } else {
            if (val === lastVal || val === lastVal * 2) setPath([...path, { row: r, col: c }]);
          }
        }
      };

      const { finalTileValue, tileMultiplier } = useMemo(() => {
        if (path.length === 0) return { finalTileValue: 0, tileMultiplier: 1 };
        let baseValue = grid[path[0].row][path[0].col].val;
        for(let i = 1; i < path.length; i++) {
          const v = grid[path[i].row][path[i].col].val;
          if (v === baseValue || v === baseValue * 2) baseValue *= 2;
        }
        const bonusPower = Math.floor((path.length - 2) / 2);
        const multiplier = Math.pow(2, Math.max(0, bonusPower));
        return { finalTileValue: baseValue * multiplier, tileMultiplier: multiplier };
      }, [path, grid]);

      const handleDragEnd = async () => {
        if (path.length < 2) { setPath([]); return; }
        setIsProcessing(true);
        const last = path[path.length - 1];
        const others = path.slice(0, -1);
        const targetId = grid[last.row][last.col].id;
        const tileColor = getTileColor(finalTileValue);

        const suckMap = new Map();
        others.forEach(p => suckMap.set(grid[p.row][p.col].id, { x: (last.col - p.col) * 70, y: (last.row - p.row) * 70 }));
        setSuckingIds(suckMap);
        await new Promise(r => setTimeout(r, 200));

        spawnParticles(last.row, last.col, tileColor);
        const g1 = grid.map(row => row.map(cell => ({...cell})));
        others.forEach(p => g1[p.row][p.col] = { val: 0, id: -1 });
        g1[last.row][last.col] = { val: finalTileValue, id: targetId };
        
        setPath([]); setSuckingIds(new Map()); setMergedId(targetId); setGrid(g1);
        setScore(s => s + finalTileValue);

        await new Promise(r => setTimeout(r, 100));

        const g2 = g1.map(row => [...row]);
        const dropMap = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let empty = 0;
          for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
            if (g2[r][c].val === 0) empty++;
            else if (empty > 0) {
              const tile = g2[r][c];
              g2[r+empty][c] = tile;
              g2[r][c] = { val: 0, id: -1 };
              dropMap.set(tile.id, empty);
            }
          }
        }
        setGrid(g2); setAnimatingIds(dropMap);
        await new Promise(r => setTimeout(r, 300));

        const g3 = g2.map(row => [...row]);
        const spawnMap = new Map(dropMap);
        for (let c = 0; c < GRID_WIDTH; c++) {
          let emptyCount = 0;
          for (let r = 0; r < GRID_HEIGHT; r++) if (g3[r][c].val === 0) emptyCount++;
          for (let r = 0; r < emptyCount; r++) {
            const newTile = createTile(getNextTileValue());
            g3[r][c] = newTile;
            spawnMap.set(newTile.id, emptyCount + 2);
          }
        }
        setGrid(g3); setAnimatingIds(spawnMap);
        await new Promise(r => setTimeout(r, 400));
        setAnimatingIds(new Map()); setMergedId(null); setIsProcessing(false);
        localStorage.setItem('mergeSaveV3', JSON.stringify({ grid: g3, score: score + finalTileValue }));
      };

      if (grid.length === 0) return null;

      return (
        <div className="flex flex-col items-center justify-between h-full w-full max-w-md py-12 px-4 font-sans">
          <div className="w-full flex justify-between items-center px-2">
            <div>
                <h1 className="text-3xl font-black text-gray-800 tracking-tighter leading-none">MERGE</h1>
                <p className="text-[10px] font-bold text-gray-400 uppercase tracking-widest">Target: 1,000,000</p>
            </div>
            <div className="bg-white shadow-sm border border-gray-100 px-6 py-2 rounded-2xl text-center">
              <p className="text-[10px] font-bold text-gray-400 uppercase">Score</p>
              <p className="text-xl font-black text-gray-800">{formatVal(score)}</p>
            </div>
          </div>

          <div className="h-24 flex items-center justify-center w-full">
            {path.length > 1 && (
              <div key={finalTileValue} className="preview-pop flex flex-col items-center justify-center bg-white w-24 h-24 rounded-full shadow-2xl border-4 relative" style={{ borderColor: getTileColor(finalTileValue) }}>
                {tileMultiplier > 1 && (
                    <div className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] font-black px-2 py-0.5 rounded-full shadow-lg border-2 border-white">
                        {tileMultiplier}x
                    </div>
                )}
                <p className="text-[9px] font-bold text-gray-400 uppercase leading-none mb-1">Result</p>
                <p className="text-2xl font-black" style={{ color: getTileColor(finalTileValue) }}>{formatVal(finalTileValue)}</p>
              </div>
            )}
          </div>

          <div 
            className="relative grid gap-2 bg-gray-900 p-3 rounded-[2.5rem] shadow-2xl"
            style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
            onTouchMove={handlePointerMove} onMouseMove={handlePointerMove}
            onMouseUp={handleDragEnd} onTouchEnd={handleDragEnd}
          >
            {grid.map((row, r) => row.map((tile, c) => {
              const coord = `${r}-${c}`;
              const isPath = path.some(p => p.row === r && p.col === c);
              const suck = suckingIds.get(tile.id);
              const dropDist = animatingIds.get(tile.id);
              const isMerge = mergedId === tile.id;

              return (
                <div
                  key={tile.id === -1 ? `empty-${coord}` : tile.id}
                  data-coord={coord}
                  onMouseDown={() => !isProcessing && setPath([{row: r, col: c}])}
                  onTouchStart={() => !isProcessing && setPath([{row: r, col: c}])}
                  className="grid-cell w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-2xl font-black text-lg relative"
                  style={{
                    backgroundColor: tile.val === 0 ? 'transparent' : getTileColor(tile.val),
                    opacity: tile.val === 0 && !suck ? 0 : 1,
                    transform: isPath ? 'scale(1.15)' : 'none',
                    zIndex: isPath ? 30 : 10,
                    boxShadow: isPath ? `0 0 25px ${getTileColor(finalTileValue)}cc` : 'none',
                    border: isPath ? `3px solid white` : 'none',
                    '--startY': `${-(dropDist || 0) * 115}%`,
                    '--suckX': `${suck?.x || 0}px`, '--suckY': `${suck?.y || 0}px`,
                    animation: dropDist ? 'gravityDrop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards' : 
                               suck ? 'suction 0.2s ease-in forwards' : 
                               isMerge ? 'popMerge 0.3s ease-out' : 'none'
                  }}
                >
                  <span className="cell-text" style={{ color: getTextColor(tile.val) }}>
                    {tile.val > 0 ? formatVal(tile.val) : ''}
                  </span>
                </div>
              );
            }))}

            {particles.map(p => (
              <div key={p.id} className="particle" style={{ left: `${p.col * 20 + 10}%`, top: `${p.row * 14.28 + 7.14}%`, width: p.size, height: p.size, backgroundColor: p.color, '--tx': `${p.tx}px`, '--ty': `${p.ty}px` }} />
            ))}
          </div>

          <button onClick={resetGame} className="w-full bg-gray-900 text-white font-black py-5 rounded-3xl shadow-xl active:scale-95 transition-transform uppercase tracking-widest text-sm">
            Reset Board
          </button>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<NumberMergeGame />);
  </script>
</body>
</html>
