<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#1f2937">
  
  <!-- PWA Meta Tags -->
  <meta name="application-name" content="Number Merge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Merge">
  <meta name="description" content="Merge numbers to create higher values in this addictive puzzle game">
  
  <!-- Apple Touch Icon (you'll need to create this) -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%231f2937'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='200' fill='%23fff' font-family='Arial, sans-serif' font-weight='bold'>2048</text></svg>">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>ðŸŽ®</text></svg>">
  
  <title>Number Merge</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Web App Manifest -->
  <link rel="manifest" href="data:application/json,{%22name%22:%22Number%20Merge%22,%22short_name%22:%22NumMerge%22,%22start_url%22:%22./%22,%22display%22:%22standalone%22,%22background_color%22:%22%231f2937%22,%22theme_color%22:%22%231f2937%22,%22orientation%22:%22portrait%22,%22icons%22:[{%22src%22:%22data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='%231f2937'/><text x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-size='200' fill='%23fff' font-family='Arial, sans-serif' font-weight='bold'>2048</text></svg>%22,%22sizes%22:%22512x512%22,%22type%22:%22image/svg+xml%22}]}">
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }
    #root {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;
    
    const CELL_SIZE = 64;
    const CELL_RADIUS = CELL_SIZE / 2;

    const COLORS = {
  1: '#4DD0E1',      // cyan
  2: '#9575CD',      // purple
  4: '#81C784',      // green
  8: '#FFD54F',      // yellow
  16: '#FF8A65',     // orange
  32: '#64B5F6',     // blue
  64: '#E57373',     // red
  128: '#4DB6AC',    // teal
  256: '#BA68C8',    // violet
  512: '#AED581',    // lime
  1024: '#FFB74D',   // amber
  2048: '#7986CB',   // indigo
  4096: '#F06292',   // pink
  8192: '#4FC3F7',   // sky blue
  16384: '#81C784',  // green (cycled, but distinct from neighbors)
  32768: '#FF8A65',
  65536: '#9575CD',
  131072: '#4DB6AC',
  262144: '#FFD54F',
  524288: '#E57373',
  1048576: '#64B5F6',
  2097152: '#BA68C8',
  4194304: '#AED581',
  8388608: '#FFB74D',
  16777216: '#7986CB',
};

const getTextColorForBackground = (hex) => {
  if (!hex) return '#111';

  const cleanHex = hex.replace('#', '');
  const r = parseInt(cleanHex.substring(0, 2), 16);
  const g = parseInt(cleanHex.substring(2, 4), 16);
  const b = parseInt(cleanHex.substring(4, 6), 16);

  // Perceived brightness (WCAG-style)
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;

  return brightness > 160 ? '#111827' : '#FFFFFF';
};

const NumberMergeGame = () => {
  const { useState, useEffect, useRef } = React;

  const [grid, setGrid] = useState([]);
  const [path, setPath] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [score, setScore] = useState(0);
  const [highestValue, setHighestValue] = useState(1);
  const [animatingCells, setAnimatingCells] = useState(new Map());      // For both existing + new tiles
  const [removedCells, setRemovedCells] = useState(new Set());
  const [suckingCells, setSuckingCells] = useState(new Map());
  const [mergedCell, setMergedCell] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const gridRef = useRef(null);

  const GRID_WIDTH = 5;
  const GRID_HEIGHT = 7;
  const CELL_SIZE = 64;
  const CELL_RADIUS = CELL_SIZE / 2;

  const COLORS = { 1:'#4DD0E1',2:'#9575CD',4:'#81C784',8:'#FFD54F',16:'#FF8A65',32:'#64B5F6',64:'#E57373',128:'#4DB6AC',256:'#BA68C8',512:'#AED581',1024:'#FFB74D',2048:'#7986CB' };

  // -----------------------------
  // Initialize grid
  // -----------------------------
  useEffect(() => initializeGrid(), []);
  const initializeGrid = () => {
    const newGrid = Array.from({ length: GRID_HEIGHT }, () =>
      Array.from({ length: GRID_WIDTH }, () => getRandomNumber())
    );
    setGrid(newGrid);
    setScore(0);
    setHighestValue(1);
  };

  const getRandomNumber = () => {
    // simple demo version
    return [1,2,4,8][Math.floor(Math.random()*4)];
  };

  // -----------------------------
  // Handle drag / merge logic
  // -----------------------------
  const handleDragEnd = async () => {
    if (!isDragging || path.length < 2 || isProcessing) {
      setIsDragging(false);
      setPath([]);
      return;
    }

    setIsProcessing(true);
    const lastCell = path[path.length - 1];
    const finalValue = 2; // simplified demo: calculate your actual merge value

    setIsDragging(false);
    setPath([]);

    // -----------------------------
    // 1ï¸âƒ£ Suction
    // -----------------------------
    const suckingAnimations = new Map();
    for (let i = 0; i < path.length - 1; i++) {
      const fromCell = path[i];
      const deltaRow = lastCell.row - fromCell.row;
      const deltaCol = lastCell.col - fromCell.col;
      suckingAnimations.set(`${fromCell.row}-${fromCell.col}`, { deltaRow, deltaCol });
    }
    setSuckingCells(suckingAnimations);
    setMergedCell(`${lastCell.row}-${lastCell.col}`);
    await new Promise(r => setTimeout(r, 180));

    // Remove path tiles except merge
    const cellsToRemove = new Set(path.slice(0, -1).map(c => `${c.row}-${c.col}`));
    setRemovedCells(cellsToRemove);
    setSuckingCells(new Map());
    await new Promise(r => setTimeout(r, 150));

    // Update merge cell
    setGrid(prev => {
      const newGrid = prev.map(r => [...r]);
      newGrid[lastCell.row][lastCell.col] = finalValue;
      return newGrid;
    });

    // -----------------------------
    // 2ï¸âƒ£ Existing tiles drop
    // -----------------------------
    const dropAnimations = new Map();
    const newGrid = grid.map(r => [...r]);

    const affectedColumns = new Set(path.map(c => c.col));
    affectedColumns.forEach(col => {
      for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
        if (newGrid[row][col] === 0) {
          for (let above = row - 1; above >= 0; above--) {
            if (newGrid[above][col] !== 0) {
              newGrid[row][col] = newGrid[above][col];
              newGrid[above][col] = 0;
              dropAnimations.set(`${row}-${col}`, row - above); // distance
              break;
            }
          }
        }
      }
    });

    setGrid(newGrid);
    setAnimatingCells(dropAnimations);
    await new Promise(r => setTimeout(r, 350));
    setAnimatingCells(new Map());

    // -----------------------------
    // 3ï¸âƒ£ New tiles drop
    // -----------------------------
    const finalGrid = newGrid.map(r => [...r]);
    const newTileAnimations = new Map();

    affectedColumns.forEach(col => {
      let emptyCount = 0;
      for (let row = 0; row < GRID_HEIGHT; row++) if (finalGrid[row][col] === 0) emptyCount++;
      for (let i = 0; i < emptyCount; i++) {
        finalGrid[i][col] = getRandomNumber();
        newTileAnimations.set(`${i}-${col}`, emptyCount - i);
      }
    });

    setGrid(finalGrid);
    setAnimatingCells(newTileAnimations);
    await new Promise(r => setTimeout(r, 350));
    setAnimatingCells(new Map());

    setScore(s => s + finalValue);
    setMergedCell(null);
    setIsProcessing(false);
  };

  // -----------------------------
  // JSX Rendering
  // -----------------------------
  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-200 p-4">
      <style>{`
        @keyframes tileDrop {
          from { transform: translateY(var(--startY)); }
          to { transform: translateY(0); }
        }
        @keyframes popMerge {
          0% { transform: scale(1); }
          50% { transform: scale(1.15); }
          100% { transform: scale(1); }
        }
      `}</style>

      <div ref={gridRef} className="grid gap-3" style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}>
        {grid.map((row, rIdx) =>
          row.map((val, cIdx) => {
            const key = `${rIdx}-${cIdx}`;
            const dropDistance = animatingCells.get(key) || 0;
            const isRemoved = removedCells.has(key);
            const isMerged = mergedCell === key;
            const suck = suckingCells.get(key);

            let transform = 'translateY(0)';
            if (suck) transform = `translate(${suck.deltaCol*CELL_SIZE}px, ${suck.deltaRow*CELL_SIZE}px) scale(0.5)`;
            if (isRemoved) transform = 'scale(0)';
            if (isMerged) transform = 'scale(1.05)';

            return (
              <div
                key={key}
                className="w-16 h-16 flex items-center justify-center rounded-2xl font-bold text-xl"
                style={{
                  backgroundColor: COLORS[val] || '#E0E0E0',
                  color: '#fff',
                  transform,
                  opacity: isRemoved ? 0 : 1,
                  transition: 'transform 0.2s ease',
                  animation: dropDistance
                    ? `tileDrop 0.35s cubic-bezier(0.22,0.61,0.36,1) forwards`
                    : undefined,
                  '--startY': `-${dropDistance*CELL_SIZE}px`,
                  ...(isMerged && !suck ? { animation: 'popMerge 0.4s ease-out' } : {})
                }}
                onPointerDown={() => !isProcessing && setPath([{ row: rIdx, col: cIdx }])}
              >
                {val}
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};
              {path.length > 1 && (
                <svg className="absolute inset-0 pointer-events-none" style={{ width: '100%', height: '100%' }}>
                  {path.slice(0, -1).map((cell, index) => {
                    const nextCell = path[index + 1];
                    const pos1 = getCellPosition(cell.row, cell.col);
                    const pos2 = getCellPosition(nextCell.row, nextCell.col);
                    if (!pos1 || !pos2) return null;
                    
                    const containerRect = gridRef.current?.getBoundingClientRect();
                    if (!containerRect) return null;
                    
                    const cx1 = pos1.x - containerRect.left;
                    const cy1 = pos1.y - containerRect.top;
                    const cx2 = pos2.x - containerRect.left;
                    const cy2 = pos2.y - containerRect.top;
                    
                    // Direction vector
const dx = cx2 - cx1;
const dy = cy2 - cy1;
const length = Math.sqrt(dx * dx + dy * dy);

// Normalize
const ux = dx / length;
const uy = dy / length;

// Offset start & end so line touches tile edge
const x1 = cx1 + ux * CELL_RADIUS;
const y1 = cy1 + uy * CELL_RADIUS;
const x2 = cx2 - ux * CELL_RADIUS;
const y2 = cy2 - uy * CELL_RADIUS;

                    const nextValue = grid[nextCell.row][nextCell.col];
                    const lineColor = COLORS[nextValue] || '#4299E1';
                    
                    return (
  <line
    key={index}
    x1={x1}
    y1={y1}
    x2={x2}
    y2={y2}
    stroke={lineColor}
    strokeWidth="8"
    strokeLinecap="round"
    opacity="0.9"
  />
);
                  })}
                </svg>
              )}
            </div>
            
            <button
              onClick={initializeGrid}
              className="mt-8 w-full bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold py-4 px-6 rounded-2xl transition-all shadow-lg"
            >
              New Game
            </button>
          </div>
        </div>
      );
    };

    ReactDOM.render(<NumberMergeGame />, document.getElementById('root'));
  </script>

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('data:text/javascript,self.addEventListener("install",%20()%20=>%20self.skipWaiting());self.addEventListener("activate",%20()%20=>%20self.clients.claim());')
          .then(() => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
</body>
</html>
