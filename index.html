<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Merge">
  
  <title>Number Merge</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body, html {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background-color: #f3f4f6; touch-action: none;
      -webkit-tap-highlight-color: transparent; user-select: none;
    }
    #root { height: 100%; display: flex; align-items: center; justify-content: center; }

    @keyframes gravityDrop {
      0% { transform: translateY(var(--startY)); }
      100% { transform: translateY(0); }
    }
    @keyframes suction {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; }
    }
    @keyframes popMerge {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    @keyframes particleFade {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    .particle {
      position: absolute; pointer-events: none; border-radius: 50%;
      z-index: 60; animation: particleFade 0.6s ease-out forwards;
    }
    .grid-cell { transition: background-color 0.2s, box-shadow 0.2s, border 0.2s; will-change: transform; }
    @keyframes indicatorPop {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }
    .preview-pop { animation: indicatorPop 0.2s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;

    // Helper to generate a color based on the number's power of 2
    const getTileColor = (val) => {
      if (val === 0) return '#374151';
      const power = Math.log2(val);
      const hue = (power * 25) % 360;
      return `hsl(${hue}, 70%, 60%)`;
    };

    const getTextColor = (val) => {
        if (val === 0) return '#fff';
        const power = Math.log2(val);
        // Darker text for lighter colors (middle of the spectrum)
        const hue = (power * 25) % 360;
        return (hue > 40 && hue < 100) ? '#111827' : '#fff';
    };

    const formatVal = (v) => {
      if (v >= 1000000000) return (v / 1000000000).toFixed(1).replace('.0','') + 'B';
      if (v >= 1000000) return (v / 1000000).toFixed(1).replace('.0','') + 'M';
      if (v >= 1000) return (v / 1000).toFixed(1).replace('.0','') + 'K';
      return v;
    };

    let globalIdCounter = 0;

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [score, setScore] = useState(0);
      const [particles, setParticles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [animatingIds, setAnimatingIds] = useState(new Map());
      const [suckingIds, setSuckingIds] = useState(new Map());
      const [mergedId, setMergedId] = useState(null);

      const createTile = (val) => ({ val, id: globalIdCounter++ });

      const getNextTileValue = (maxOnGrid) => {
        // As you get into Millions, we need to drop higher base numbers so the game stays playable
        const maxExp = Math.floor(Math.log2(maxOnGrid || 1));
        const dropExpLimit = Math.max(3, Math.min(8, maxExp - 4)); 
        return Math.pow(2, Math.floor(Math.random() * dropExpLimit) + 1);
      };

      useEffect(() => {
        const saved = localStorage.getItem('mergeSaveObj');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            if (data.grid && typeof data.grid[0][0] === 'object') {
              setGrid(data.grid);
              setScore(data.score || 0);
              globalIdCounter = Math.max(...data.grid.flat().map(t => t.id)) + 1;
            } else { resetGame(); }
          } catch (e) { resetGame(); }
        } else { resetGame(); }
      }, []);

      const resetGame = () => {
        globalIdCounter = 0;
        const startGrid = Array.from({length: GRID_HEIGHT}, () => 
          Array.from({length: GRID_WIDTH}, () => createTile(Math.pow(2, Math.floor(Math.random() * 3) + 1)))
        );
        setGrid(startGrid);
        setScore(0);
        setPath([]);
      };

      const spawnParticles = (row, col, color) => {
        const newParticles = Array.from({ length: 15 }).map((_, i) => ({
          id: Math.random() + i, row, col, color,
          tx: (Math.random() - 0.5) * 200, ty: (Math.random() - 0.5) * 200, size: Math.random() * 6 + 4
        }));
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.filter(p => !newParticles.includes(p))), 600);
      };

      const handleDragStart = (r, c) => { if (!isProcessing) setPath([{ row: r, col: c }]); };

      const handlePointerMove = (e) => {
        if (path.length === 0 || isProcessing) return;
        const touch = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!el || !el.dataset.coord) return;
        
        const [r, c] = el.dataset.coord.split('-').map(Number);
        const last = path[path.length - 1];
        if (last.row === r && last.col === c) return;

        if (path.length > 1) {
          const secondLast = path[path.length - 2];
          if (secondLast.row === r && secondLast.col === c) {
            setPath(path.slice(0, -1));
            return;
          }
        }

        const isAdj = Math.abs(last.row - r) <= 1 && Math.abs(last.col - c) <= 1;
        const val = grid[r][c].val;
        const lastVal = grid[last.row][last.col].val;

        if (isAdj && !path.find(p => p.row === r && p.col === c)) {
          if (path.length === 1) {
            if (val === lastVal) setPath([...path, { row: r, col: c }]);
          } else {
            // Can connect to same value or the current projected total
            if (val === lastVal || val === lastVal * 2) setPath([...path, { row: r, col: c }]);
          }
        }
      };

      // THE CORE TILE MULTIPLIER LOGIC
      const { finalTileValue, tileMultiplier } = useMemo(() => {
        if (path.length === 0) return { finalTileValue: 0, tileMultiplier: 1 };
        
        let baseValue = grid[path[0].row][path[0].col].val;
        for(let i = 1; i < path.length; i++) {
          const v = grid[path[i].row][path[i].col].val;
          if (v === baseValue || v === baseValue * 2) baseValue *= 2;
        }

        // TILE BONUS: Every 2 tiles above the initial 2 doubles the final result
        // 2-3 tiles: 1x, 4-5 tiles: 2x, 6-7 tiles: 4x, 8+ tiles: 8x
        const bonusPower = Math.floor((path.length - 2) / 2);
        const multiplier = Math.pow(2, Math.max(0, bonusPower));
        
        return { 
          finalTileValue: baseValue * multiplier, 
          tileMultiplier: multiplier 
        };
      }, [path, grid]);

      const handleDragEnd = async () => {
        if (path.length < 2) { setPath([]); return; }
        setIsProcessing(true);

        const last = path[path.length - 1];
        const others = path.slice(0, -1);
        const targetId = grid[last.row][last.col].id;
        const tileColor = getTileColor(finalTileValue);

        const suckMap = new Map();
        others.forEach(p => suckMap.set(grid[p.row][p.col].id, { x: (last.col - p.col) * 70, y: (last.row - p.row) * 70 }));
        setSuckingIds(suckMap);
        
        await new Promise(r => setTimeout(r, 200));

        spawnParticles(last.row, last.col, tileColor);
        const g1 = grid.map(row => row.map(cell => ({...cell})));
        others.forEach(p => g1[p.row][p.col] = { val: 0, id: -1 });
        g1[last.row][last.col] = { val: finalTileValue, id: targetId };
        
        setPath([]);
        setSuckingIds(new Map());
        setMergedId(targetId);
        setGrid(g1);
        setScore(s => s + finalTileValue);

        await new Promise(r => setTimeout(r, 100));

        const g2 = g1.map(row => [...row]);
        const dropMap = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let empty = 0;
          for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
            if (g2[r][c].val === 0) empty++;
            else if (empty > 0) {
              const tile = g2[r][c];
              g2[r+empty][c] = tile;
              g2[r][c] = { val: 0, id: -1 };
              dropMap.set(tile.id, empty);
            }
          }
        }
        setGrid(g2);
        setAnimatingIds(dropMap);

        await new Promise(r => setTimeout(r, 300));

        const maxOnBoard = Math.max(...g2.flat().map(t => t.val));
        const g3 = g2.map(row => [...row]);
        const spawnMap = new Map(dropMap);
        for (let c = 0; c < GRID_WIDTH; c++) {
          let emptyCount = 0;
          for (let r = 0; r < GRID_HEIGHT; r++) if (g3[r][c].val === 0) emptyCount++;
          for (let r = 0; r < emptyCount; r++) {
            const newTile = createTile(getNextTileValue(maxOnBoard));
            g3[r][c] = newTile;
            spawnMap.set(newTile.id, emptyCount + 2);
          }
        }
        setGrid(g3);
        setAnimatingIds(spawnMap);

        await new Promise(r => setTimeout(r, 400));
        setAnimatingIds(new Map());
        setMergedId(null);
        setIsProcessing(false);
        localStorage.setItem('mergeSaveObj', JSON.stringify({ grid: g3, score: score + finalTileValue }));
      };

      if (grid.length === 0) return null;

      return (
        <div className="flex flex-col items-center justify-between h-full w-full max-w-md py-12 px-4">
          <div className="w-full flex justify-between items-center px-2">
            <div>
                <h1 className="text-3xl font-black text-gray-800 tracking-tighter leading-none">MERGE</h1>
                <p className="text-[10px] font-bold text-blue-500 uppercase tracking-widest">Tile-Jump Edition</p>
            </div>
            <div className="bg-white shadow-sm border border-gray-100 px-6 py-2 rounded-2xl text-center">
              <p className="text-[10px] font-bold text-gray-400 uppercase">Total Score</p>
              <p className="text-xl font-black text-gray-800">{formatVal(score)}</p>
            </div>
          </div>

          <div className="h-24 flex items-center justify-center w-full">
            {path.length > 1 && (
              <div key={finalTileValue} className="preview-pop flex flex-col items-center justify-center bg-white w-24 h-24 rounded-full shadow-xl border-4 relative" style={{ borderColor: getTileColor(finalTileValue) }}>
                {tileMultiplier > 1 && (
                    <div className="absolute -top-2 -right-2 bg-red-500 text-white text-xs font-black px-2 py-1 rounded-full shadow-lg border-2 border-white">
                        {tileMultiplier}x
                    </div>
                )}
                <p className="text-[9px] font-bold text-gray-400 uppercase leading-none mb-1">New Tile</p>
                <p className="text-2xl font-black" style={{ color: getTileColor(finalTileValue) }}>{formatVal(finalTileValue)}</p>
              </div>
            )}
          </div>

          <div 
            className="relative grid gap-2 bg-gray-900 p-3 rounded-[2.5rem] shadow-2xl overflow-hidden"
            style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
            onTouchMove={handlePointerMove} onMouseMove={handlePointerMove}
            onMouseUp={handleDragEnd} onTouchEnd={handleDragEnd}
          >
            {grid.map((row, r) => row.map((tile, c) => {
              const coord = `${r}-${c}`;
              const isPath = path.some(p => p.row === r && p.col === c);
              const suck = suckingIds.get(tile.id);
              const dropDist = animatingIds.get(tile.id);
              const isMerge = mergedId === tile.id;

              return (
                <div
                  key={tile.id === -1 ? `empty-${coord}` : tile.id}
                  data-coord={coord}
                  onMouseDown={() => handleDragStart(r, c)}
                  onTouchStart={() => handleDragStart(r, c)}
                  className="grid-cell w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-2xl font-black text-lg relative"
                  style={{
                    backgroundColor: tile.val === 0 ? 'transparent' : getTileColor(tile.val),
                    opacity: tile.val === 0 && !suck ? 0 : 1,
                    transform: isPath ? 'scale(1.15)' : 'none',
                    zIndex: isPath ? 30 : 10,
                    boxShadow: isPath ? `0 0 30px ${getTileColor(finalTileValue)}cc` : 'none',
                    border: isPath ? `3px solid white` : 'none',
                    '--startY': `${-(dropDist || 0) * 100}%`,
                    '--suckX': `${suck?.x || 0}px`, '--suckY': `${suck?.y || 0}px`,
                    animation: dropDist ? 'gravityDrop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards' : 
                               suck ? 'suction 0.2s ease-in forwards' : 
                               isMerge ? 'popMerge 0.3s ease-out' : 'none'
                  }}
                >
                  <span className="cell-text" style={{ color: getTextColor(tile.val) }}>
                    {tile.val > 0 ? formatVal(tile.val) : ''}
                  </span>
                </div>
              );
            }))}

            {particles.map(p => (
              <div 
                key={p.id} className="particle"
                style={{
                  left: `${p.col * 20 + 10}%`, top: `${p.row * 14.28 + 7.14}%`,
                  width: p.size, height: p.size, backgroundColor: p.color,
                  '--tx': `${p.tx}px`, '--ty': `${p.ty}px`
                }}
              />
            ))}
          </div>

          <button onClick={resetGame} className="w-full bg-gray-900 text-white font-black py-5 rounded-3xl shadow-xl active:scale-95 transition-transform uppercase tracking-widest text-sm">
            Reset Board
          </button>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<NumberMergeGame />);
  </script>
</body>
</html>
