<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Number Merge Mobile</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #f3f4f6;
      touch-action: none;
    }

    #root {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- ANIMATIONS --- */
    @keyframes gravityDrop {
      0% { transform: translateY(var(--startY)); }
      60% { transform: translateY(8px); }
      80% { transform: translateY(-4px); }
      100% { transform: translateY(0); }
    }

    @keyframes suction {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; }
    }

    @keyframes popMerge {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    @keyframes particleFade {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    /* New animation for the path indicator */
    @keyframes indicatorPop {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      z-index: 50;
      animation: particleFade 0.6s ease-out forwards;
    }

    .preview-pop {
      animation: indicatorPop 0.2s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;
    const COLORS = {
      1: '#4DD0E1', 2: '#9575CD', 4: '#81C784', 8: '#FFD54F',
      16: '#FF8A65', 32: '#64B5F6', 64: '#E57373', 128: '#4DB6AC',
      256: '#BA68C8', 512: '#AED581', 1024: '#FFB74D', 2048: '#7986CB',
      4096: '#F06292', 8192: '#4FC3F7', 16384: '#81C784', 32768: '#FF8A65'
    };

    const getTextColor = (hex) => {
      if (!hex) return '#fff';
      const r = parseInt(hex.slice(1,3), 16), g = parseInt(hex.slice(3,5), 16), b = parseInt(hex.slice(5,7), 16);
      return (r*299 + g*587 + b*114)/1000 > 160 ? '#111827' : '#fff';
    };

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [score, setScore] = useState(0);
      const [particles, setParticles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [animatingCells, setAnimatingCells] = useState(new Map());
      const [suckingCells, setSuckingCells] = useState(new Map());
      const [mergedCell, setMergedCell] = useState(null);
      const gridRef = useRef(null);

      useEffect(() => {
        const saved = localStorage.getItem('mergeSave');
        if (saved) {
          const data = JSON.parse(saved);
          setGrid(data.grid);
          setScore(data.score);
        } else {
          resetGame();
        }
      }, []);

      const resetGame = () => {
        const startGrid = Array.from({length: GRID_HEIGHT}, () => 
          Array.from({length: GRID_WIDTH}, () => Math.pow(2, Math.floor(Math.random() * 3)))
        );
        setGrid(startGrid);
        setScore(0);
        setPath([]);
      };

      const spawnParticles = (row, col, color) => {
        const newParticles = Array.from({ length: 12 }).map((_, i) => ({
          id: Date.now() + i,
          row, col, color,
          tx: (Math.random() - 0.5) * 150,
          ty: (Math.random() - 0.5) * 150,
          size: Math.random() * 8 + 4
        }));
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.filter(p => !newParticles.includes(p))), 600);
      };

      const handleDragStart = (r, c) => {
        if (isProcessing) return;
        setPath([{ row: r, col: c }]);
      };

      const handlePointerMove = (e) => {
        if (path.length === 0 || isProcessing) return;
        const touch = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!el || !el.dataset.coord) return;
        
        const [r, c] = el.dataset.coord.split('-').map(Number);
        const last = path[path.length - 1];
        if (last.row === r && last.col === c) return;

        if (path.length > 1) {
          const secondLast = path[path.length - 2];
          if (secondLast.row === r && secondLast.col === c) {
            setPath(path.slice(0, -1));
            return;
          }
        }

        const isAdj = Math.abs(last.row - r) <= 1 && Math.abs(last.col - c) <= 1;
        const val = grid[r][c];
        const lastVal = grid[last.row][last.col];
        if (isAdj && !path.find(p => p.row === r && p.col === c)) {
          if (val === lastVal || (path.length >= 1 && val === lastVal * 2)) {
            setPath([...path, { row: r, col: c }]);
          }
        }
      };

      // Calculate path value in real-time
      const pathValue = useMemo(() => {
        if (path.length === 0) return 0;
        let total = grid[path[0].row][path[0].col];
        for(let i = 1; i < path.length; i++) {
          const v = grid[path[i].row][path[i].col];
          if (v === total || v === total * 2) total *= 2;
        }
        return total;
      }, [path, grid]);

      const handleDragEnd = async () => {
        if (path.length < 2) { setPath([]); return; }
        setIsProcessing(true);
        const finalVal = pathValue;
        const last = path[path.length - 1];
        const others = path.slice(0, -1);

        const suck = new Map();
        others.forEach(p => suck.set(`${p.row}-${p.col}`, { x: (last.col - p.col) * 66, y: (last.row - p.row) * 66 }));
        setSuckingCells(suck);
        const savedPath = [...path]; // Save for gravity calculation
        setPath([]);

        await new Promise(r => setTimeout(r, 200));

        spawnParticles(last.row, last.col, COLORS[finalVal] || '#fff');
        const g1 = grid.map(row => [...row]);
        others.forEach(p => g1[p.row][p.col] = 0);
        g1[last.row][last.col] = finalVal;
        setMergedCell(`${last.row}-${last.col}`);
        setSuckingCells(new Map());

        const drops = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let empty = 0;
          for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
            if (g1[r][c] === 0) empty++;
            else if (empty > 0) {
              g1[r+empty][c] = g1[r][c];
              g1[r][c] = 0;
              drops.set(`${r+empty}-${c}`, empty);
            }
          }
        }
        setGrid(g1);
        setAnimatingCells(drops);

        await new Promise(r => setTimeout(r, 400));

        const g2 = g1.map(row => [...row]);
        const spawns = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let count = 0;
          for (let r = 0; r < GRID_HEIGHT; r++) if (g2[r][c] === 0) count++;
          for (let i = 0; i < count; i++) {
            g2[i][c] = Math.pow(2, Math.floor(Math.random() * 3));
            spawns.set(`${i}-${c}`, count + 1);
          }
        }
        setGrid(g2);
        setAnimatingCells(spawns);
        const newScore = score + finalVal;
        setScore(newScore);

        await new Promise(r => setTimeout(r, 400));
        setAnimatingCells(new Map());
        setMergedCell(null);
        setIsProcessing(false);
        localStorage.setItem('mergeSave', JSON.stringify({ grid: g2, score: newScore }));
      };

      const formatVal = (v) => v >= 1000 ? (v/1000)+'K' : v;

      return (
        <div className="flex flex-col items-center justify-between h-full w-full max-w-md py-8 px-4">
          {/* Header */}
          <div className="w-full flex justify-between items-center px-2">
            <div>
              <h1 className="text-3xl font-black text-gray-800 tracking-tighter">MERGE</h1>
              <p className="text-xs font-bold text-gray-400 uppercase tracking-widest">Puzzle Game</p>
            </div>
            <div className="bg-white shadow-sm border border-gray-100 px-6 py-2 rounded-2xl text-center">
              <p className="text-[10px] font-bold text-gray-400 uppercase">Score</p>
              <p className="text-xl font-black text-gray-800">{score.toLocaleString()}</p>
            </div>
          </div>

          {/* NEW: Visual Path Indicator */}
          <div className="h-20 flex items-center justify-center w-full">
            {path.length > 0 && (
              <div 
                key={pathValue} // Re-mounting triggers the indicatorPop animation
                className="preview-pop flex items-center gap-4 bg-white px-6 py-3 rounded-3xl shadow-lg border-2"
                style={{ borderColor: COLORS[pathValue] || '#eee' }}
              >
                <div className="text-center">
                  <p className="text-[9px] font-bold text-gray-400 uppercase leading-none">Result</p>
                  <p className="text-2xl font-black" style={{ color: COLORS[pathValue] }}>
                    {formatVal(pathValue)}
                  </p>
                </div>
                <div className="w-[1px] h-8 bg-gray-100"></div>
                <div className="text-center">
                  <p className="text-[9px] font-bold text-gray-400 uppercase leading-none">Cells</p>
                  <p className="text-2xl font-black text-gray-800">{path.length}</p>
                </div>
              </div>
            )}
          </div>

          {/* Grid */}
          <div 
            ref={gridRef}
            className="relative grid gap-2 bg-gray-900 p-3 rounded-[2rem] shadow-2xl"
            style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
            onTouchMove={handlePointerMove}
            onMouseMove={handlePointerMove}
            onMouseUp={handleDragEnd}
            onTouchEnd={handleDragEnd}
          >
            {grid.map((row, r) => row.map((val, c) => {
              const key = `${r}-${c}`;
              const isPath = path.some(p => p.row === r && p.col === c);
              const isPathLast = path.length > 0 && path[path.length-1].row === r && path[path.length-1].col === c;
              const suck = suckingCells.get(key);
              const drop = animatingCells.get(key);
              const isMerge = mergedCell === key;

              return (
                <div
                  key={key}
                  data-coord={key}
                  onMouseDown={() => handleDragStart(r, c)}
                  onTouchStart={() => handleDragStart(r, c)}
                  className="grid-cell w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-xl sm:rounded-2xl font-black text-lg sm:text-xl transition-all duration-150"
                  style={{
                    backgroundColor: COLORS[val] || '#374151',
                    color: getTextColor(COLORS[val]),
                    opacity: val === 0 && !suck ? 0 : 1,
                    transform: isPath ? 'scale(1.1)' : 'none',
                    zIndex: isPath ? 10 : 1,
                    boxShadow: isPath ? `0 0 20px ${COLORS[pathValue]}cc` : 'none',
                    border: isPath ? `3px solid white` : 'none',
                    '--startY': `${-(drop || 0) * 74}px`,
                    '--suckX': `${suck?.x || 0}px`,
                    '--suckY': `${suck?.y || 0}px`,
                    animation: drop ? 'gravityDrop 0.4s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards' : 
                               suck ? 'suction 0.2s ease-in forwards' : 
                               isMerge ? 'popMerge 0.3s ease-out' : 'none'
                  }}
                >
                  {val > 0 ? formatVal(val) : ''}
                </div>
              );
            }))}

            {/* Particle Layer */}
            {particles.map(p => (
              <div 
                key={p.id} 
                className="particle"
                style={{
                  left: `${p.col * 20 + 10}%`,
                  top: `${p.row * 14 + 7}%`,
                  width: p.size, height: p.size,
                  backgroundColor: p.color,
                  '--tx': `${p.tx}px`, '--ty': `${p.ty}px`
                }}
              />
            ))}
          </div>

          <button 
            onClick={resetGame}
            className="w-full bg-gray-900 text-white font-black py-5 rounded-3xl shadow-xl active:scale-95 transition-transform uppercase tracking-widest text-sm"
          >
            New Game
          </button>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<NumberMergeGame />);
  </script>
</body>
</html>
