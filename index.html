<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Number Merge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #f3f4f6; touch-action: none; -webkit-tap-highlight-color: transparent; user-select: none; }
    #root { height: 100%; display: flex; align-items: center; justify-content: center; }
    @keyframes gravityDrop { 0% { transform: translateY(var(--startY)); } 100% { transform: translateY(0); } }
    @keyframes suction { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; } }
    @keyframes popMerge { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
    @keyframes particleFade { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
    .particle { position: absolute; pointer-events: none; border-radius: 50%; z-index: 60; animation: particleFade 0.6s ease-out forwards; }
    .grid-cell { transition: background-color 0.2s, box-shadow 0.2s, border 0.2s; will-change: transform; }
    .preview-pop { animation: indicatorPop 0.2s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards; }
    @keyframes indicatorPop { 0% { transform: scale(0.8); opacity: 0; } 50% { transform: scale(1.1); } 100% { transform: scale(1); opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;

    const TILE_COLORS = {
      2: '#47D1FF', 4: '#A855F7', 8: '#22C55E', 16: '#F59E0B',
      32: '#EF4444', 64: '#3B82F6', 128: '#EC4899', 256: '#10B981',
      512: '#6366F1', 1024: '#F97316', 2048: '#06B6D4', 4096: '#8B5CF6'
    };

    const getTileColor = (val) => TILE_COLORS[val] || `hsl(${(Math.log2(val) * 45) % 360}, 75%, 45%)`;
    const getTextColor = (val) => [2, 8, 16, 256].includes(val) ? '#111827' : '#fff';

    const formatVal = (v) => {
      if (v >= 1000000) return (v / 1000000).toFixed(v % 1000000 === 0 ? 0 : 1) + 'M';
      if (v >= 1000) return (v / 1000).toFixed(v % 1000 === 0 ? 0 : 1) + 'K';
      return v;
    };

    let globalIdCounter = 0;

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [score, setScore] = useState(0);
      const [particles, setParticles] = useState([]);
      const [isProcessing, setIsProcessing] = useState(false);
      const [animatingIds, setAnimatingIds] = useState(new Map());
      const [suckingIds, setSuckingIds] = useState(new Map());
      const [mergedId, setMergedId] = useState(null);

      const createTile = (val) => ({ val, id: globalIdCounter++ });

      // CHAOTIC SPAWNING: Randomizes 2, 4, 8, and occasionally 16 to block easy paths
      const getNextTileValue = () => {
        const weights = [2, 2, 2, 4, 4, 8, 8, 16];
        return weights[Math.floor(Math.random() * weights.length)];
      };

      useEffect(() => {
        const saved = localStorage.getItem('mergeSaveHard');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            setGrid(data.grid);
            setScore(data.score || 0);
            globalIdCounter = Math.max(...data.grid.flat().map(t => t.id)) + 1;
          } catch (e) { resetGame(); }
        } else { resetGame(); }
      }, []);

      const resetGame = () => {
        globalIdCounter = 0;
        const startGrid = Array.from({length: GRID_HEIGHT}, () => 
          Array.from({length: GRID_WIDTH}, () => createTile(getNextTileValue()))
        );
        setGrid(startGrid);
        setScore(0);
        setPath([]);
      };

      const handlePointerMove = (e) => {
        if (path.length === 0 || isProcessing) return;
        const touch = e.touches ? e.touches[0] : e;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!el || !el.dataset.coord) return;
        const [r, c] = el.dataset.coord.split('-').map(Number);
        const last = path[path.length - 1];
        if (last.row === r && last.col === c) return;

        if (path.length > 1) {
          const secondLast = path[path.length - 2];
          if (secondLast.row === r && secondLast.col === c) {
            setPath(path.slice(0, -1)); return;
          }
        }

        const isAdj = Math.abs(last.row - r) <= 1 && Math.abs(last.col - c) <= 1;
        const val = grid[r][c].val;
        const lastVal = grid[last.row][last.col].val;

        if (isAdj && !path.find(p => p.row === r && p.col === c)) {
            // Path logic: Next tile must be identical to the last tile
            // Or, if path is long, it can be the next power of 2
            if (val === lastVal || (path.length > 1 && val === lastVal * 2)) {
                setPath([...path, { row: r, col: c }]);
            }
        }
      };

      // CHALLENGING MULTIPLIER LOGIC
      const { finalTileValue, tileMultiplier } = useMemo(() => {
        if (path.length === 0) return { finalTileValue: 0, tileMultiplier: 1 };
        
        let val = grid[path[0].row][path[0].col].val;
        // Every tile added contributes to the growth, but it's much slower
        for(let i = 1; i < path.length; i++) {
            val *= 1.25; // 25% growth per step instead of doubling
        }
        
        // Round to nearest power of 2 to keep tiles standard
        let finalVal = Math.pow(2, Math.round(Math.log2(val)));
        
        // Bonus only for true mastery (long runs)
        let multiplier = 1;
        if (path.length >= 6) multiplier = 2;
        if (path.length >= 10) multiplier = 4;
        
        return { finalTileValue: finalVal * multiplier, tileMultiplier: multiplier };
      }, [path, grid]);

      const handleDragEnd = async () => {
        if (path.length < 2) { setPath([]); return; }
        setIsProcessing(true);
        const last = path[path.length - 1];
        const others = path.slice(0, -1);
        const targetId = grid[last.row][last.col].id;
        const tileColor = getTileColor(finalTileValue);

        const suckMap = new Map();
        others.forEach(p => suckMap.set(grid[p.row][p.col].id, { x: (last.col - p.col) * 70, y: (last.row - p.row) * 70 }));
        setSuckingIds(suckMap);
        await new Promise(r => setTimeout(r, 200));

        const g1 = grid.map(row => row.map(cell => ({...cell})));
        others.forEach(p => g1[p.row][p.col] = { val: 0, id: -1 });
        g1[last.row][last.col] = { val: finalTileValue, id: targetId };
        
        setPath([]); setSuckingIds(new Map()); setMergedId(targetId); setGrid(g1);
        setScore(s => s + finalTileValue);

        await new Promise(r => setTimeout(r, 100));
        const g2 = g1.map(row => [...row]);
        const dropMap = new Map();
        for (let c = 0; c < GRID_WIDTH; c++) {
          let empty = 0;
          for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
            if (g2[r][c].val === 0) empty++;
            else if (empty > 0) {
              const tile = g2[r][c];
              g2[r+empty][c] = tile;
              g2[r][c] = { val: 0, id: -1 };
              dropMap.set(tile.id, empty);
            }
          }
        }
        setGrid(g2); setAnimatingIds(dropMap);
        await new Promise(r => setTimeout(r, 300));

        const g3 = g2.map(row => [...row]);
        const spawnMap = new Map(dropMap);
        for (let c = 0; c < GRID_WIDTH; c++) {
          let emptyCount = 0;
          for (let r = 0; r < GRID_HEIGHT; r++) if (g3[r][c].val === 0) emptyCount++;
          for (let r = 0; r < emptyCount; r++) {
            const newTile = createTile(getNextTileValue());
            g3[r][c] = newTile;
            spawnMap.set(newTile.id, emptyCount + 2);
          }
        }
        setGrid(g3); setAnimatingIds(spawnMap);
        await new Promise(r => setTimeout(r, 400));
        setAnimatingIds(new Map()); setMergedId(null); setIsProcessing(false);
        localStorage.setItem('mergeSaveHard', JSON.stringify({ grid: g3, score: score + finalTileValue }));
      };

      return (
        <div className="flex flex-col items-center justify-between h-full w-full max-w-md py-12 px-4 font-sans">
          <div className="w-full flex justify-between items-center px-2">
            <div>
                <h1 className="text-3xl font-black text-gray-800 tracking-tighter leading-none">MERGE</h1>
                <p className="text-[10px] font-bold text-red-500 uppercase tracking-widest">Hard Mode</p>
            </div>
            <div className="bg-white shadow-sm border border-gray-100 px-6 py-2 rounded-2xl text-center">
              <p className="text-[10px] font-bold text-gray-400 uppercase">Score</p>
              <p className="text-xl font-black text-gray-800">{formatVal(score)}</p>
            </div>
          </div>

          <div className="h-24 flex items-center justify-center w-full">
            {path.length > 1 && (
              <div key={finalTileValue} className="preview-pop flex flex-col items-center justify-center bg-white w-24 h-24 rounded-full shadow-2xl border-4 relative" style={{ borderColor: getTileColor(finalTileValue) }}>
                {tileMultiplier > 1 && (
                    <div className="absolute -top-1 -right-1 bg-black text-white text-[10px] font-black px-2 py-0.5 rounded-full shadow-lg border-2 border-white">
                        BONUS
                    </div>
                )}
                <p className="text-[9px] font-bold text-gray-400 uppercase leading-none mb-1">Target</p>
                <p className="text-2xl font-black" style={{ color: getTileColor(finalTileValue) }}>{formatVal(finalTileValue)}</p>
              </div>
            )}
          </div>

          <div 
            className="relative grid gap-2 bg-gray-900 p-3 rounded-[2.5rem] shadow-2xl"
            style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)` }}
            onTouchMove={handlePointerMove} onMouseMove={handlePointerMove}
            onMouseUp={handleDragEnd} onTouchEnd={handleDragEnd}
          >
            {grid.map((row, r) => row.map((tile, c) => (
                <div
                  key={tile.id === -1 ? `empty-${r}-${c}` : tile.id}
                  data-coord={`${r}-${c}`}
                  onMouseDown={() => !isProcessing && setPath([{row: r, col: c}])}
                  onTouchStart={() => !isProcessing && setPath([{row: r, col: c}])}
                  className="grid-cell w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center rounded-2xl font-black text-lg relative"
                  style={{
                    backgroundColor: tile.val === 0 ? 'transparent' : getTileColor(tile.val),
                    opacity: tile.val === 0 && !suckingIds.has(tile.id) ? 0 : 1,
                    transform: path.some(p => p.row === r && p.col === c) ? 'scale(1.15)' : 'none',
                    zIndex: path.some(p => p.row === r && p.col === c) ? 30 : 10,
                    boxShadow: path.some(p => p.row === r && p.col === c) ? `0 0 25px ${getTileColor(finalTileValue)}cc` : 'none',
                    border: path.some(p => p.row === r && p.col === c) ? `3px solid white` : 'none',
                    '--startY': `${-(animatingIds.get(tile.id) || 0) * 115}%`,
                    '--suckX': `${suckingIds.get(tile.id)?.x || 0}px`, '--suckY': `${suckingIds.get(tile.id)?.y || 0}px`,
                    animation: animatingIds.has(tile.id) ? 'gravityDrop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards' : 
                               suckingIds.has(tile.id) ? 'suction 0.2s ease-in forwards' : 
                               mergedId === tile.id ? 'popMerge 0.3s ease-out' : 'none'
                  }}
                >
                  <span className="cell-text" style={{ color: getTextColor(tile.val) }}>
                    {tile.val > 0 ? formatVal(tile.val) : ''}
                  </span>
                </div>
            )))}
          </div>

          <button onClick={resetGame} className="w-full bg-gray-900 text-white font-black py-5 rounded-3xl shadow-xl active:scale-95 transition-transform uppercase tracking-widest text-sm">
            Reset Game
          </button>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<NumberMergeGame />);
  </script>
</body>
</html>
