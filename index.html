<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#1f2937">
  
  <meta name="application-name" content="Number Merge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Number Merge">
  <meta name="description" content="Merge numbers to create higher values in this addictive puzzle game">
  
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>ðŸŽ®</text></svg>">
  
  <title>Number Merge</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      background-color: #f3f4f6;
    }
    #root {
      width: 100%;
      height: 100%;
    }

    /* --- ANIMATIONS --- */
    @keyframes gravityDrop {
      0% { transform: translateY(var(--startY)); }
      60% { transform: translateY(8px); }
      80% { transform: translateY(-4px); }
      100% { transform: translateY(0); }
    }

    @keyframes suction {
      0% { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--suckX), var(--suckY)) scale(0.2); opacity: 0; }
    }

    @keyframes popMerge {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    @keyframes valuePulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .pulse-animation {
      animation: valuePulse 0.2s ease-out;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const GRID_WIDTH = 5;
    const GRID_HEIGHT = 7;
    const CELL_SIZE = 64;

    const COLORS = {
      1: '#4DD0E1', 2: '#9575CD', 4: '#81C784', 8: '#FFD54F',
      16: '#FF8A65', 32: '#64B5F6', 64: '#E57373', 128: '#4DB6AC',
      256: '#BA68C8', 512: '#AED581', 1024: '#FFB74D', 2048: '#7986CB',
      4096: '#F06292', 8192: '#4FC3F7', 16384: '#81C784', 32768: '#FF8A65',
      65536: '#9575CD', 131072: '#4DB6AC', 262144: '#FFD54F', 524288: '#E57373',
      1048576: '#64B5F6', 2097152: '#BA68C8', 4194304: '#AED581', 8388608: '#FFB74D',
      16777216: '#7986CB',
    };

    const getTextColorForBackground = (hex) => {
      if (!hex) return '#111';
      const cleanHex = hex.replace('#', '');
      const r = parseInt(cleanHex.substring(0, 2), 16);
      const g = parseInt(cleanHex.substring(2, 4), 16);
      const b = parseInt(cleanHex.substring(4, 6), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 160 ? '#111827' : '#FFFFFF';
    };

    const NumberMergeGame = () => {
      const [grid, setGrid] = useState([]);
      const [path, setPath] = useState([]);
      const [isDragging, setIsDragging] = useState(false);
      const [score, setScore] = useState(0);
      const [highestValue, setHighestValue] = useState(1);
      const [deprecatedValues, setDeprecatedValues] = useState(new Set());
      const [animatingCells, setAnimatingCells] = useState(new Map());
      const [suckingCells, setSuckingCells] = useState(new Map());
      const [mergedCell, setMergedCell] = useState(null);
      const [isProcessing, setIsProcessing] = useState(false);
      const gridRef = useRef(null);

      useEffect(() => { loadGame(); }, []);

      const saveGame = (currentGrid, currentScore, currentHighest, currentDeprecated) => {
        const gameState = {
          grid: currentGrid,
          score: currentScore,
          highestValue: currentHighest,
          deprecatedValues: Array.from(currentDeprecated),
        };
        localStorage.setItem('numberMergeGame', JSON.stringify(gameState));
      };

      const loadGame = () => {
        const saved = localStorage.getItem('numberMergeGame');
        if (saved) {
          const { grid: savedGrid, score: savedScore, highestValue: savedHighest, deprecatedValues: savedDeprecated } = JSON.parse(saved);
          setGrid(savedGrid);
          setScore(savedScore);
          setHighestValue(savedHighest || 1);
          setDeprecatedValues(new Set(savedDeprecated));
        } else {
          initializeGrid();
        }
      };

      const getAvailableNumbers = (currentHighest, currentDeprecated) => {
        const allNumbers = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216];
        const highestIndex = allNumbers.indexOf(currentHighest);
        const startIndex = Math.max(0, highestIndex - 5);
        const endIndex = Math.max(startIndex + 3, highestIndex - 2);
        const rangeNumbers = allNumbers.slice(startIndex, endIndex);
        return rangeNumbers.filter(n => !currentDeprecated.has(n));
      };

      const getRandomNumber = (currentHighest = highestValue, currentDeprecated = deprecatedValues) => {
        const available = getAvailableNumbers(currentHighest, currentDeprecated);
        const weights = available.map((_, i) => Math.pow(0.7, i));
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        let random = Math.random() * totalWeight;
        for (let i = 0; i < available.length; i++) {
          random -= weights[i];
          if (random <= 0) return available[i];
        }
        return available[0];
      };

      const initializeGrid = () => {
        const newGrid = Array.from({ length: GRID_HEIGHT }, () => 
          Array.from({ length: GRID_WIDTH }, () => getRandomNumber(1, new Set()))
        );
        setGrid(newGrid);
        setScore(0);
        setHighestValue(1);
        setDeprecatedValues(new Set());
      };

      const formatNumber = (num) => {
        if (num < 1000) return num.toString();
        if (num < 1000000) return `${(num / 1000).toFixed(num % 1000 === 0 ? 0 : 1)}K`;
        return `${(num / 1000000).toFixed(num % 1000000 === 0 ? 0 : 1)}M`;
      };

      const getCellPosition = (row, col) => {
        if (!gridRef.current) return null;
        const cells = gridRef.current.querySelectorAll('.grid-cell');
        const cell = cells[row * GRID_WIDTH + col];
        if (!cell) return null;
        const rect = cell.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      };

      const getCellFromPointer = (x, y) => {
        const element = document.elementFromPoint(x, y);
        if (!element || !element.classList.contains('grid-cell')) return null;
        const cells = Array.from(gridRef.current?.querySelectorAll('.grid-cell') || []);
        const index = cells.indexOf(element);
        return index === -1 ? null : { row: Math.floor(index / GRID_WIDTH), col: index % GRID_WIDTH };
      };

      const isAdjacent = (cell1, cell2) => {
        const rowDiff = Math.abs(cell1.row - cell2.row);
        const colDiff = Math.abs(cell1.col - cell2.col);
        return rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0);
      };

      const canAddToPath = (newCell) => {
        if (path.length === 0) return true;
        const lastCell = path[path.length - 1];
        if (path.some(cell => cell.row === newCell.row && cell.col === newCell.col)) return false;
        if (!isAdjacent(lastCell, newCell)) return false;
        
        const lastValue = grid[lastCell.row][lastCell.col];
        const newValue = grid[newCell.row][newCell.col];
        
        if (path.length === 1) return lastValue === newValue;
        return newValue === lastValue || newValue === lastValue * 2;
      };

      const handleDragStart = (row, col) => {
        if (isProcessing) return;
        setIsDragging(true);
        setPath([{ row, col }]);
      };

      const handlePointerMove = (e) => {
        if (!isDragging) return;
        const cell = getCellFromPointer(e.clientX, e.clientY);
        if (!cell) return;

        const lastCell = path[path.length - 1];
        if (lastCell.row === cell.row && lastCell.col === cell.col) return;

        if (path.length >= 2) {
          const prevCell = path[path.length - 2];
          if (prevCell.row === cell.row && prevCell.col === cell.col) {
            setPath(path.slice(0, -1));
            return;
          }
        }

        if (canAddToPath(cell)) setPath([...path, cell]);
      };

      const getPathValue = () => {
        if (path.length === 0) return 0;
        let currentValue = grid[path[0].row][path[0].col];
        let sameValueCount = 1;
        for (let i = 1; i < path.length; i++) {
          const cellValue = grid[path[i].row][path[i].col];
          const prevValue = grid[path[i - 1].row][path[i - 1].col];
          if (cellValue > prevValue) {
            currentValue *= 2;
            sameValueCount = 1;
          } else if (cellValue === prevValue) {
            sameValueCount++;
            if (sameValueCount === 2 || sameValueCount === 3 || (sameValueCount > 3 && sameValueCount % 2 === 1)) {
              currentValue *= 2;
            }
          }
        }
        return currentValue;
      };

      const handleDragEnd = async () => {
        if (!isDragging || path.length < 2 || isProcessing) {
          setIsDragging(false);
          setPath([]);
          return;
        }

        setIsProcessing(true);
        const finalValue = getPathValue();
        const lastCell = path[path.length - 1];
        const pathCoords = path.slice(0, -1);

        const suckMap = new Map();
        pathCoords.forEach(cell => {
          suckMap.set(`${cell.row}-${cell.col}`, {
            x: (lastCell.col - cell.col) * 76,
            y: (lastCell.row - cell.row) * 76
          });
        });

        setSuckingCells(suckMap);
        setIsDragging(false);
        setPath([]);

        await new Promise(r => setTimeout(r, 200));

        const g1 = grid.map(row => [...row]);
        const dropMap = new Map();

        pathCoords.forEach(c => { g1[c.row][c.col] = 0; });
        g1[lastCell.row][lastCell.col] = finalValue;
        setMergedCell(`${lastCell.row}-${lastCell.col}`);
        setSuckingCells(new Map());

        for (let col = 0; col < GRID_WIDTH; col++) {
          let empty = 0;
          for (let row = GRID_HEIGHT - 1; row >= 0; row--) {
            if (g1[row][col] === 0) {
              empty++;
            } else if (empty > 0) {
              const val = g1[row][col];
              g1[row + empty][col] = val;
              g1[row][col] = 0;
              dropMap.set(`${row + empty}-${col}`, empty);
            }
          }
        }

        setGrid(g1);
        setAnimatingCells(dropMap);
        await new Promise(r => setTimeout(r, 400));

        const g2 = g1.map(row => [...row]);
        const spawnMap = new Map();

        for (let col = 0; col < GRID_WIDTH; col++) {
          let emptyCount = 0;
          for (let row = 0; row < GRID_HEIGHT; row++) {
            if (g2[row][col] === 0) emptyCount++;
          }
          for (let i = 0; i < emptyCount; i++) {
            g2[i][col] = getRandomNumber(Math.max(highestValue, finalValue));
            spawnMap.set(`${i}-${col}`, emptyCount + 1);
          }
        }

        setGrid(g2);
        setAnimatingCells(spawnMap);
        await new Promise(r => setTimeout(r, 400));

        setAnimatingCells(new Map());
        setMergedCell(null);
        const newScore = score + finalValue;
        setScore(newScore);
        
        let newHighest = highestValue;
        if (finalValue > highestValue) newHighest = finalValue;
        setHighestValue(newHighest);

        setIsProcessing(false);
        saveGame(g2, newScore, newHighest, deprecatedValues);
      };

      const pathValue = useMemo(() => getPathValue(), [path, grid]);

      return (
        <div className="flex flex-col items-center justify-center min-h-screen p-4">
          <div className="bg-white rounded-3xl p-8 shadow-2xl max-w-md w-full">
            
            {/* --- HEADER --- */}
            <div className="flex justify-between items-center mb-6">
              <h1 className="text-3xl font-bold text-gray-800">Merge</h1>
              <div className="bg-purple-100 px-4 py-2 rounded-full">
                <span className="text-purple-800 font-semibold">Score: {score.toLocaleString()}</span>
              </div>
            </div>
            
            {/* --- NEW VISUAL INDICATOR --- */}
            <div className="mb-6 flex flex-col items-center justify-center" style={{ height: '80px' }}>
              {path.length > 0 ? (
                <div 
                  key={pathValue} // Key helps trigger animation on value change
                  className="pulse-animation flex items-center gap-3 bg-gray-50 px-6 py-3 rounded-2xl shadow-inner border border-gray-100 transition-all duration-200"
                >
                  <div className="flex flex-col items-center">
                    <span className="text-[10px] uppercase tracking-wider text-gray-400 font-bold">Cells</span>
                    <span className="text-xl font-black text-gray-700">{path.length}</span>
                  </div>
                  
                  <div className="h-8 w-[2px] bg-gray-200 rounded-full"></div>
                  
                  <div 
                    className="px-6 py-2 rounded-xl text-2xl font-black shadow-sm transition-colors duration-300"
                    style={{ 
                      backgroundColor: COLORS[pathValue] || '#E0E0E0', 
                      color: getTextColorForBackground(COLORS[pathValue])
                    }}
                  >
                    {formatNumber(pathValue)}
                  </div>
                </div>
              ) : (
                <div className="text-gray-300 font-medium italic animate-pulse">
                  Select 2 or more to merge...
                </div>
              )}
            </div>
            
            {/* --- GRID --- */}
            <div 
              ref={gridRef}
              className="grid gap-3 relative select-none bg-gray-900 p-4 rounded-3xl"
              style={{ gridTemplateColumns: `repeat(${GRID_WIDTH}, 1fr)`, touchAction: 'none' }}
              onPointerMove={handlePointerMove}
              onPointerUp={handleDragEnd}
              onPointerCancel={handleDragEnd}
            >
              {grid.map((row, rowIndex) =>
                row.map((value, colIndex) => {
                  const cellKey = `${rowIndex}-${colIndex}`;
                  const isInPath = path.some(p => p.row === rowIndex && p.col === colIndex);
                  const dropDist = animatingCells.get(cellKey);
                  const suckData = suckingCells.get(cellKey);
                  const isMerged = mergedCell === cellKey;
                  
                  const cellStyle = {
                    backgroundColor: COLORS[value] || '#374151',
                    color: getTextColorForBackground(COLORS[value]),
                    opacity: value === 0 && !suckData ? 0 : 1,
                    '--startY': `${-(dropDist || 0) * 76}px`,
                    '--suckX': `${suckData?.x || 0}px`,
                    '--suckY': `${suckData?.y || 0}px`,
                    zIndex: isInPath ? 20 : 1
                  };

                  let animation = '';
                  if (dropDist) animation = 'gravityDrop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
                  else if (suckData) animation = 'suction 0.2s ease-in forwards';
                  else if (isMerged) animation = 'popMerge 0.3s ease-out';

                  return (
                    <div
                      key={cellKey}
                      className="grid-cell w-16 h-16 flex items-center justify-center rounded-2xl font-bold text-xl cursor-pointer transition-transform"
                      style={{
                        ...cellStyle,
                        animation,
                        transform: isInPath ? 'scale(1.15)' : 'none',
                        boxShadow: isInPath ? `0 0 20px ${COLORS[value]}88` : 'none',
                        border: isInPath ? '3px solid white' : 'none'
                      }}
                      onPointerDown={() => handleDragStart(rowIndex, colIndex)}
                    >
                      {value !== 0 ? formatNumber(value) : ''}
                    </div>
                  );
                })
              )}
              
              {path.length > 1 && (
                <svg className="absolute inset-0 pointer-events-none" style={{ width: '100%', height: '100%' }}>
                  {path.slice(0, -1).map((cell, index) => {
                    const nextCell = path[index + 1];
                    const pos1 = getCellPosition(cell.row, cell.col);
                    const pos2 = getCellPosition(nextCell.row, nextCell.col);
                    if (!pos1 || !pos2 || !gridRef.current) return null;
                    const rect = gridRef.current.getBoundingClientRect();
                    return (
                      <line
                        key={index}
                        x1={pos1.x - rect.left} y1={pos1.y - rect.top}
                        x2={pos2.x - rect.left} y2={pos2.y - rect.top}
                        stroke={COLORS[grid[nextCell.row][nextCell.col]] || '#fff'}
                        strokeWidth="8" strokeLinecap="round" opacity="0.8"
                      />
                    );
                  })}
                </svg>
              )}
            </div>
            
            <button
              onClick={initializeGrid}
              className="mt-8 w-full bg-gray-800 hover:bg-black text-white font-bold py-4 rounded-2xl transition-all shadow-lg active:scale-95"
            >
              Reset Board
            </button>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<NumberMergeGame />);
  </script>
</body>
</html>
