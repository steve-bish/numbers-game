<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
<meta name="theme-color" content="#1f2937">

<title>Number Merge</title>

<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #e5e7eb;
}
</style>
</head>

<body>
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

const GRID_WIDTH = 5;
const GRID_HEIGHT = 7;
const CELL_SIZE = 64;
const CELL_RADIUS = CELL_SIZE / 2;

const COLORS = {
  1:'#4DD0E1',2:'#9575CD',4:'#81C784',8:'#FFD54F',
  16:'#FF8A65',32:'#64B5F6',64:'#E57373',
  128:'#4DB6AC',256:'#BA68C8',512:'#AED581',
  1024:'#FFB74D',2048:'#7986CB'
};

const NumberMergeGame = () => {
  const [grid, setGrid] = useState([]);
  const [path, setPath] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const [score, setScore] = useState(0);
  const [highestValue, setHighestValue] = useState(1);

  const [animatingCells, setAnimatingCells] = useState(new Map());
  const [removedCells, setRemovedCells] = useState(new Set());
  const [suckingCells, setSuckingCells] = useState(new Map());
  const [mergedCell, setMergedCell] = useState(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const gridRef = useRef(null);

  useEffect(() => initializeGrid(), []);

  const getRandomNumber = () => [1,2,4,8][Math.floor(Math.random()*4)];

  const initializeGrid = () => {
    const g = Array.from({length: GRID_HEIGHT}, () =>
      Array.from({length: GRID_WIDTH}, getRandomNumber)
    );
    setGrid(g);
    setScore(0);
    setHighestValue(1);
  };

  const handleDragStart = (row,col) => {
    if (isProcessing) return;
    setIsDragging(true);
    setPath([{row,col}]);
  };

  const handleDragEnd = async () => {
    if (!isDragging || path.length < 2 || isProcessing) {
      setIsDragging(false);
      setPath([]);
      return;
    }

    setIsProcessing(true);
    const last = path[path.length - 1];
    const finalValue = grid[last.row][last.col] * 2;

    setIsDragging(false);
    setPath([]);

    /* 1️⃣ SUCTION */
    const suckMap = new Map();
    for (let i=0;i<path.length-1;i++) {
      const c = path[i];
      suckMap.set(`${c.row}-${c.col}`, {
        deltaRow: last.row - c.row,
        deltaCol: last.col - c.col
      });
    }
    setSuckingCells(suckMap);
    setMergedCell(`${last.row}-${last.col}`);
    await new Promise(r => setTimeout(r,180));

    const removed = new Set(path.slice(0,-1).map(c=>`${c.row}-${c.col}`));
    setRemovedCells(removed);
    setSuckingCells(new Map());
    await new Promise(r => setTimeout(r,150));

    setGrid(prev=>{
      const g = prev.map(r=>[...r]);
      g[last.row][last.col] = finalValue;
      return g;
    });

    /* 2️⃣ EXISTING DROP */
    const dropMap = new Map();
    const g1 = grid.map(r=>[...r]);
    const cols = new Set(path.map(p=>p.col));

    cols.forEach(col=>{
      for (let r=GRID_HEIGHT-1;r>=0;r--) {
        if (g1[r][col]===0) {
          for (let a=r-1;a>=0;a--) {
            if (g1[a][col]!==0) {
              g1[r][col]=g1[a][col];
              g1[a][col]=0;
              dropMap.set(`${r}-${col}`, r-a);
              break;
            }
          }
        }
      }
    });

    setGrid(g1);
    setAnimatingCells(dropMap);
    await new Promise(r=>setTimeout(r,350));
    setAnimatingCells(new Map());

    /* 3️⃣ NEW TILES */
    const g2 = g1.map(r=>[...r]);
    const spawnMap = new Map();

    cols.forEach(col=>{
      let empty=0;
      for (let r=0;r<GRID_HEIGHT;r++) if (g2[r][col]===0) empty++;
      for (let i=0;i<empty;i++) {
        g2[i][col]=getRandomNumber();
        spawnMap.set(`${i}-${col}`, empty-i);
      }
    });

    setGrid(g2);
    setAnimatingCells(spawnMap);
    await new Promise(r=>setTimeout(r,350));
    setAnimatingCells(new Map());

    setRemovedCells(new Set());
    setMergedCell(null);
    setScore(s=>s+finalValue);
    setIsProcessing(false);
  };

  return (
    <div className="flex items-center justify-center min-h-screen">
      <style>{`
        @keyframes tileDrop {
          from { transform: translateY(var(--startY)); }
          to { transform: translateY(0); }
        }
        @keyframes popMerge {
          0%{transform:scale(1)}
          50%{transform:scale(1.15)}
          100%{transform:scale(1)}
        }
      `}</style>

      <div className="grid gap-3 bg-gray-900 p-4 rounded-3xl"
        ref={gridRef}
        style={{gridTemplateColumns:`repeat(${GRID_WIDTH},1fr)`}}
        onPointerUp={handleDragEnd}
        onPointerCancel={handleDragEnd}
      >
        {grid.map((row,r)=>row.map((val,c)=>{
          const key=`${r}-${c}`;
          const drop=animatingCells.get(key);
          const suck=suckingCells.get(key);

          return (
            <div key={key}
              onPointerDown={()=>handleDragStart(r,c)}
              className="w-16 h-16 flex items-center justify-center rounded-2xl font-bold text-xl text-white"
              style={{
                backgroundColor: COLORS[val],
                transform:
                  suck ? `translate(${suck.deltaCol*CELL_SIZE}px,${suck.deltaRow*CELL_SIZE}px) scale(0.5)`
                  : removedCells.has(key) ? 'scale(0)' : 'translateY(0)',
                animation:
                  drop ? 'tileDrop 0.35s cubic-bezier(0.22,0.61,0.36,1) forwards'
                  : mergedCell===key ? 'popMerge 0.4s ease-out' : undefined,
                '--startY': drop ? `${-drop*CELL_SIZE}px` : '0px',
                transition: 'transform 0.2s ease'
              }}>
              {val}
            </div>
          );
        }))}
      </div>
    </div>
  );
};

ReactDOM.render(<NumberMergeGame />, document.getElementById('root'));
</script>
</body>
</html>